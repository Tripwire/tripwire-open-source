//
// The developer of the original code and/or files is Tripwire, Inc.
// Portions created by Tripwire, Inc. are copyright (C) 2000-2019 Tripwire,
// Inc. Tripwire is a registered trademark of Tripwire, Inc.  All rights
// reserved.
// 
// This program is free software.  The contents of this file are subject
// to the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.  You may redistribute it and/or modify it
// only in compliance with the GNU General Public License.
// 
// This program is distributed in the hope that it will be useful.
// However, this program is distributed AS-IS WITHOUT ANY
// WARRANTY; INCLUDING THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
// FOR A PARTICULAR PURPOSE.  Please see the GNU General Public License
// for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
// USA.
// 
// Nothing in the GNU General Public License or any other license to use
// the code or files shall permit you to use Tripwire's trademarks,
// service marks, or other intellectual property without Tripwire's
// prior written consent.
// 
// If you have any questions, please contact Tripwire, Inc. at either
// info@tripwire.org or www.tripwire.org.
//
#include "stdtwparser.h"

// There was a problem with varargs on some combo of old OpenBSD & old compiler.
// Not needed with current, but it's here if you need it.
#ifdef TW_OLD_OPENBSD_VARARGS
# undef va_start
# ifdef __GNUC__
#  define va_start(ap, last) \
        ((ap) = (va_list)__builtin_next_arg(last))
# else
#  define va_start(ap, last) \
        ((ap) = (va_list)&(last) + __va_size(last))
# endif
#endif // TW_OLD_OPENBSD_VARARGS

/* ..\. -a -o yylex.cpp -D yylex.h -P ..\..\mkslexyacc\etc\yylex.cpp -LC tokens.l */
#define INITIAL 0
#define globals 2
const int yy_endst = 172;
const int yy_nxtmax = 2818;
#define YY_LA_SIZE 22

static unsigned int yy_la_act[] = {
 12, 37, 34, 37, 14, 37, 15, 37, 16, 37, 17, 37, 34, 37, 19, 37,
 20, 37, 21, 37, 22, 37, 23, 37, 24, 37, 25, 37, 34, 37, 37, 36,
 37, 35, 34, 26, 18, 14, 13, 12, 12, 37, 34, 37, 34, 34, 34, 34,
 34, 34, 34, 34, 32, 34, 34, 34, 34, 34, 34, 31, 34, 33, 34, 34,
 30, 34, 34, 29, 34, 34, 34, 34, 34, 28, 34, 34, 34, 34, 34, 34,
 27, 34, 34, 34, 34, 34, 34, 34, 0, 34, 34, 34, 34, 34, 0, 34,
 0, 0, 32, 31, 33, 30, 29, 28, 27, 12, 3, 11, 6, 11, 5, 11,
 6, 11, 11, 8, 11, 9, 11, 10, 11, 7, 6, 5, 4, 3, 3, 11,
 6, 11, 6, 6, 6, 6, 6, 6, 2, 6, 6, 6, 6, 6, 6, 1,
 6, 2, 1, 3, 0
};

static unsigned char yy_look[] = {
 0
};

static int yy_final[] = {
 0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
 30, 31, 32, 33, 33, 33, 34, 34, 35, 36, 37, 38, 39, 40, 40, 42,
 44, 45, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59,
 61, 63, 64, 66, 67, 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80,
 82, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 96, 96, 96,
 96, 96, 96, 96, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98,
 98, 99, 99, 99, 99, 99, 99, 100, 101, 101, 102, 102, 103, 103, 103, 103,
 103, 104, 104, 104, 104, 104, 104, 105, 106, 106, 106, 106, 108, 110, 112, 114,
 115, 117, 119, 120, 121, 121, 121, 122, 122, 123, 124, 125, 126, 126, 128, 130,
 131, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 145, 145,
 145, 145, 145, 146, 146, 146, 146, 146, 146, 147, 148, 148, 148
};
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif

static yy_state_t yy_begin[] = {
 0, 29, 122, 140, 0
};

static yy_state_t yy_next[] = {
 15, 15, 15, 15, 15, 15, 15, 15, 15, 1, 17, 15, 15, 1, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 1, 6, 16, 3, 14, 15, 15, 15, 10, 11, 15, 15, 12, 7, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 9, 15, 8, 18, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 2, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 4, 13, 5, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 24, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 21, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 25, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 27, 32, 23, 23, 38, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 39, 40, 41, 45, 28, 23, 23, 23, 28, 46, 23, 23, 47, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 28, 23, 48, 49, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 50, 51, 52, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 53, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
 30, 33, 54, 55, 30, 33, 42, 56, 43, 57, 58, 59, 44, 60, 61, 62,
 63, 64, 67, 68, 69, 64, 70, 30, 33, 71, 72, 73, 74, 75, 76, 79,
 80, 64, 81, 82, 83, 64, 84, 85, 64, 86, 87, 88, 33, 93, 94, 95,
 33, 96, 100, 97, 101, 98, 102, 31, 64, 99, 103, 104, 105, 106, 107, 108,
 109, 110, 111, 33, 112, 113, 114, 115, 116, 117, 118, 121, 119, 138, 139, 66,
 119, 143, 139, 141, 147, 148, 149, 141, 150, 151, 152, 153, 154, 36, 155, 78,
 156, 35, 159, 119, 160, 139, 161, 162, 37, 163, 141, 34, 164, 165, 166, 65,
 167, 168, 171, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 77,
 172, 172, 172, 120, 172, 172, 172, 172, 91, 172, 142, 172, 90, 172, 172, 172,
 172, 172, 172, 92, 172, 172, 89, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 123, 130, 126, 126, 123, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 123, 131, 127, 125, 131, 126, 126, 126, 131,
 131, 126, 126, 131, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 128, 126, 129, 131, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 124, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 131, 131, 131, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 172, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 134, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 133, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132,
 132, 132, 132, 132, 132, 132, 132, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 172, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
 135, 135, 135, 135, 135, 135, 135, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 172, 172, 136, 136, 172, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 172, 172, 172, 172, 172, 136, 136, 136, 172,
 172, 136, 136, 172, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 172, 136, 172, 172, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 172, 172, 172, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136,
 136, 136, 136, 136, 136, 136, 136, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 172, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137, 137, 144, 144, 169, 172, 144, 144, 169, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 144, 144,
 169, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 170, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 146, 158,
 172, 145, 157, 0
};

static yy_state_t yy_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 7, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 2, 31, 15, 15, 37, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 38, 39, 40, 44, 1, 15, 15, 15, 1, 45, 15, 15, 46, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 1, 15, 43, 48, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 49, 42, 51, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 29, 32, 53, 54, 29, 32, 36, 55, 36, 56, 34, 58, 36, 59, 60, 61,
 62, 63, 66, 67, 68, 63, 69, 29, 32, 70, 65, 72, 73, 74, 75, 78,
 79, 64, 80, 81, 82, 64, 77, 84, 63, 85, 86, 87, 33, 92, 93, 94,
 33, 95, 99, 91, 100, 91, 101, 29, 64, 91, 98, 103, 104, 97, 106, 90,
 108, 109, 110, 33, 111, 89, 113, 114, 115, 116, 117, 120, 30, 124, 123, 63,
 30, 142, 123, 140, 146, 147, 148, 140, 149, 145, 151, 152, 153, 32, 154, 64,
 155, 32, 158, 30, 159, 123, 160, 161, 32, 157, 140, 32, 163, 164, 165, 63,
 166, 167, 170, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 64,
 255, 255, 255, 30, 255, 255, 255, 255, 33, 255, 140, 255, 33, 255, 255, 255,
 255, 255, 255, 33, 255, 255, 33, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
 122, 122, 122, 122, 122, 122, 122, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 255, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
 127, 127, 127, 127, 127, 127, 127, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 255, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
 133, 133, 133, 133, 133, 133, 133, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 255, 255, 126, 126, 255, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 255, 255, 255, 255, 255, 126, 126, 126, 255,
 255, 126, 126, 255, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 255, 126, 255, 255, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 255, 255, 255, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126,
 126, 126, 126, 126, 126, 126, 126, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 255, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
 125, 125, 125, 125, 125, 125, 125, 143, 144, 141, 255, 143, 144, 141, 255, 255,
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 143, 144,
 141, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
 141, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 143, 144,
 255, 143, 144, 0
};

static yy_state_t yy_default[] = {
 172, 172, 15, 172, 172, 172, 172, 15, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 16, 172, 172, 16, 15, 172, 172, 3, 172, 1, 0, 172, 15,
 15, 172, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 172, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 64, 30, 172, 33, 172, 172, 126, 172, 172, 172,
 172, 172, 172, 172, 127, 172, 172, 127, 126, 125, 172, 123, 122, 172, 126, 126,
 172, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 172, 172, 172,
 172, 172, 172, 172, 172, 172, 172, 172, 172, 141, 172, 144, 0
};

static int yy_base[] = {
 0, 795, 767, 1024, 2819, 2819, 2819, 460, 2819, 2819, 2819, 2819, 2819, 142, 2819, 768,
 256, 2819, 2819, 2819, 512, 2819, 2819, 2819, 2819, 2819, 2819, 2819, 2819, 1271, 1347, 714,
 1272, 1315, 1189, 932, 1178, 667, 695, 691, 686, 2819, 777, 729, 689, 698, 698, 2819,
 725, 789, 2819, 792, 2819, 1178, 1172, 1172, 1173, 2819, 1192, 1177, 1189, 1184, 1186, 1288,
 1304, 1198, 1222, 1220, 1234, 1237, 1229, 2819, 1196, 1210, 1212, 1202, 2819, 1210, 1235, 1233,
 1248, 1250, 1240, 2819, 1208, 1223, 1225, 1215, 2819, 1248, 1241, 1223, 1211, 1221, 1217, 1213,
 2819, 1226, 1238, 1216, 1221, 1220, 2819, 1234, 1238, 2819, 1241, 2819, 1240, 1234, 1231, 1232,
 2819, 1251, 1235, 1247, 1242, 1244, 2819, 2819, 1291, 2819, 1431, 1349, 1347, 2455, 2199, 1687,
 2819, 2819, 2819, 2819, 2819, 1943, 2819, 2819, 2819, 2819, 2819, 2819, 1354, 2704, 1297, 2702,
 2703, 1268, 1250, 1260, 1256, 1252, 2819, 1271, 1255, 1267, 1263, 1266, 2819, 1284, 1264, 1275,
 1272, 1267, 2819, 1289, 1273, 1285, 1281, 1283, 2819, 2819, 1330, 2819, 2819
};


// #line 152 "..\\..\\mkslexyacc\\etc\\yylex.cpp"

// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define YY_INTERACTIVE  1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2) fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const int MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define BEGIN       yy_start =
#define REJECT      goto yy_reject
#define yymore()    goto yy_more

// #line 10 "tokens.l"

#include "stdtwparser.h"

//#ifndef YYNEWLINE
# include "twparser/yylex.h"
# include "twparser/yyparse.h"
//#endif

#include <stdio.h>
#if HAVE_MALLOC_H && !IS_AROS
#include <malloc.h>
#endif
#include <stdlib.h>

#include "core/debug.h" 

#include "policyparser.h"
#include "parserhelper.h"
#include "genreparseinfo.h"
#include "core/stringutil.h"
#include "core/displayencoder.h"



/* specify that the lexer exit on EOF */
int yywrap()
{
    return 1;
}

/* wrapper around cDebug tracing */
void lextrace(const TCHAR*str)
{
    cDebug d("\t\t\t\tlexer");
    d.TraceDetail( _T("%s\n"), str);
}

// since i've replaced this with a non-va_arg yyerror,
// call this when you hit a syntax error and then call
// the non-va_arg yyerror with the result
std::string FormatSyntaxError( char ch, const char* pszAdditionalMsg = NULL )
{
    // TODO:BAM MKS will call yyerror with narrow-char hard-coded string, so if 
    // we do it here as well, I suppose that's OK.  This should be eventually
    // corrected.

    TOSTRINGSTREAM ssErr; 
    ssErr << "Syntax error: \'" << ch << "\'";
    if( pszAdditionalMsg )
        ssErr << ", " << pszAdditionalMsg;

    tss_return_stream(ssErr, out);
}

// saves typing
#define TRACE_RETURN(x) lextrace(_T(#x)); return x

// #line 178 "..\\..\\mkslexyacc\\etc\\yylex.cpp"


// Constructor for yy_scan. Set up tables
//#pragma argsused
yy_scan::yy_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
    mustfree = 0;
    if ((size = sz) < MIN_NUM_STATES
      || (yytext = buf) == 0
      || (state = states) == 0) {
        yyerror("Bad space for scanner!");
        exit(1);
    }
#ifdef YY_PRESERVE
    save = sv;
#endif
}
// Constructor for yy_scan. Set up tables
yy_scan::yy_scan(int sz)
{
    size = sz;
    yytext = new char[sz+1];    // text buffer
    state = new yy_state_t[sz+1];   // state buffer
#ifdef YY_PRESERVE
    save = new char[sz];    // saved yytext[]
    push = save + sz;
#endif
    if (yytext == NULL
#ifdef YY_PRESERVE
      || save == NULL
#endif
      || state == NULL) {
        yyerror("No space for scanner!");
        exit(1);
    }
    mustfree = 1;
    yy_end = 0;
    yy_start = 0;
    yy_lastc = YYNEWLINE;
    yyin = stdin;
    yyout = stdout;
    yylineno = 1;
    yyleng = 0;
}

// Descructor for yy_scan
yy_scan::~yy_scan()
{
    if (mustfree) {
        mustfree = 0;
        delete [] yytext;
        delete [] state;
#ifdef YY_PRESERVE
        delete [] save;
#endif
    }
}

// Print error message, showing current line number
void
yy_scan::yyerror(const char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
#ifdef LEX_WINDOWS
    // Windows has no concept of a standard error output!
    // send output to yyout as a simple solution
    if (yylineno)
        fprintf(yyout, "%d: ", yylineno);
    (void) vfprintf(yyout, fmt, va);
    fputc('\n', yyout);
#else /* LEX_WINDOWS */
    if (yylineno)
        fprintf(stderr, "%d: ", yylineno);
    (void) vfprintf(stderr, fmt, va);
    fputc('\n', stderr);
#endif /* LEX_WINDOWS */
    va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yylex() to acutally begin the
// scanning. When complete, win_yylex() will return a
// value back to our new yylex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yylex().

int
yy_scan::yylex()
{
    int wReturnValue;
    HANDLE hRes_table;
    unsigned short far *old_yy_la_act;  // remember old pointer values
    short far *old_yy_final;
    yy_state_t far *old_yy_begin;
    yy_state_t far *old_yy_next;
    yy_state_t far *old_yy_check;
    yy_state_t far *old_yy_default;
    short far *old_yy_base;

    // the following code will load the required
    // resources for a Windows based parser. 

    hRes_table = LoadResource (hInst,
        FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
    
    // return an error code if any
    // of the resources did not load 

    if (hRes_table == (HANDLE)NULL) 
        return (0);
    
    // the following code will lock the resources
    // into fixed memory locations for the scanner
    // (remember previous pointer locations)

    old_yy_la_act = yy_la_act;
    old_yy_final = yy_final;
    old_yy_begin = yy_begin;
    old_yy_next = yy_next;
    old_yy_check = yy_check;
    old_yy_default = yy_default;
    old_yy_base = yy_base;

    yy_la_act = (unsigned short far *)LockResource (hRes_table);
    yy_final = (short far *)(yy_la_act + Sizeof_yy_la_act);
    yy_begin = (yy_state_t far *)(yy_final + Sizeof_yy_final);
    yy_next = (yy_state_t far *)(yy_begin + Sizeof_yy_begin);
    yy_check = (yy_state_t far *)(yy_next + Sizeof_yy_next);
    yy_default = (yy_state_t far *)(yy_check + Sizeof_yy_check);
    yy_base = (short far *)(yy_default + Sizeof_yy_default);


    // call the standard yylex() code

    wReturnValue = win_yylex();

    // unlock the resources

    UnlockResource (hRes_table);

    // and now free the resource

    FreeResource (hRes_table);

    //
    // restore previously saved pointers
    //

    yy_la_act = old_yy_la_act;
    yy_final = old_yy_final;
    yy_begin = old_yy_begin;
    yy_next = old_yy_next;
    yy_check = old_yy_check;
    yy_default = old_yy_default;
    yy_base = old_yy_base;

    return (wReturnValue);
}   // end yylex()

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
yy_scan::win_yylex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
yy_scan::yylex()
#endif /* LEX_WINDOWS */

{
    int c, i, yybase;
    unsigned  yyst;     /* state */
    int yyfmin, yyfmax; /* yy_la_act indices of final states */
    int yyoldi, yyoleng;    /* base i, yyleng before look-ahead */
    int yyeof;      /* 1 if eof has already been read */

// #line 375 "..\\..\\mkslexyacc\\etc\\yylex.cpp"


#ifdef YYEXIT
    yyLexFatal = 0;
#endif
    yyeof = 0;
    i = yyleng;
    YY_SCANNER();

  yy_again:
    if ((yyleng = i) > 0) {
        yy_lastc = yytext[i-1]; // determine previous char
        while (i > 0)   //  // scan previously token
            if (yytext[--i] == YYNEWLINE)   // fix yylineno
                yylineno++;
    }
    yy_end -= yyleng;       // adjust pushback
    if (yy_end > 0)
        memmove(yytext, yytext+yyleng, (size_t) yy_end);
    i = 0;

  yy_contin:
    yyoldi = i;

    /* run the state machine until it jams */
    yyst = yy_begin[yy_start + ((yy_lastc == YYNEWLINE) ? 1 : 0)];
    state[i] = (yy_state_t) yyst;
    do {
        YY_DEBUG("<state %d, i = %d>\n", yyst, i);
        if (i >= size) {
            YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
            if (yyLexFatal)
                return -2;
#endif
        }   /* endif */

        /* get input char */
        if (i < yy_end)
            c = yytext[i];      /* get pushback char */
        else if (!yyeof && (c = yygetc()) != EOF) {
            yy_end = i+1;
            yytext[i] = c;
        } else /* c == EOF */ {
            c = EOF;        /* just to make sure... */
            if (i == yyoldi) {  /* no token */
                yyeof = 0;
                if (yywrap())
                    return 0;
                else
                    goto yy_again;
            } else {
                yyeof = 1;  /* don't re-read EOF */
                break;
            }
        }
        YY_DEBUG("<input %d = 0x%02x>\n", c, c);

        /* look up next state */
        while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
            || yy_check[yybase] != (yy_state_t) yyst) {
            if (yyst == (unsigned int)yy_endst)
                goto yy_jammed;
            yyst = yy_default[yyst];
        }
        yyst = yy_next[yybase];
      yy_jammed: ;
         state[++i] = (yy_state_t) yyst;
    } while (!(yyst == (unsigned int)yy_endst || (YY_INTERACTIVE &&
        (yy_base[yyst] > yy_nxtmax) && (yy_default[yyst] == yy_endst))));

    YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
    if (yyst != (unsigned int)yy_endst)
        ++i;

  yy_search:
    /* search backward for a final state */
    while (--i > yyoldi) {
        yyst = state[i];
        if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
            goto yy_found;  /* found final state(s) */
    }
    /* no match, default action */
    i = yyoldi + 1;
    output(yytext[yyoldi]);
    goto yy_again;

  yy_found:
    YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
    yyoleng = i;        /* save length for REJECT */
    
    // pushback look-ahead RHS, handling trailing context
    if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
        unsigned char *bv = yy_look + c*YY_LA_SIZE;
        static unsigned char bits [8] = {
            1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
        };
        while (1) {
            if (--i < yyoldi) { /* no / */
                i = yyoleng;
                break;
            }
            yyst = state[i];
            if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
                break;
        }
    }

    /* perform action */
    yyleng = i;
    YY_USER();
    switch (yy_la_act[yyfmin] & 0777) {
    case 0:
// #line 109 "tokens.l"
    {
                    BEGIN( globals );
                }
    break;
    case 1:
// #line 114 "tokens.l"
    {
                    BEGIN(INITIAL);
                    return TWP_SECTION;
                }
    break;
    case 2:
// #line 119 "tokens.l"
    { TRACE_RETURN(TWP_ECHO); }
    break;
    case 3:
// #line 122 "tokens.l"
    { 
                    lextrace(_T("eating spaces..."));            /* eat spaces */ 
                }
    break;
    case 4:
// #line 125 "tokens.l"
    {   
                    cParserHelper::IncrementLineNumber();
                    lextrace(_T("eating line continuation...")); /* eat line continuations */ 
                }
    break;
    case 5:
// #line 129 "tokens.l"
    {
                    lextrace(_T("eating comment..."));
                }
    break;
    case 6:
// #line 138 "tokens.l"
    { 
                        // we must make copy of string, otherwise another lexeme will clobber it
                        cDebug d("\t\t\t\tlexer::string");

                        // convert LPCSTR to TSTRING
                        cParseString *mpstring = new cParseString;
                        ASSERT(mpstring);
                        *mpstring = cStringUtil::StrToTstr( yytext );

                        d.TraceDetail("--> <%s>\n", mpstring->c_str());

                        // attach to lval
                        yylval.mpString = mpstring;
                        
                        return TWP_GLOBAL_STRING;
                    }
    break;
    case 7:
// #line 155 "tokens.l"
    {
                        // we must make copy of string, otherwise another lexeme will clobber it
                        cDebug d("\t\t\t\tlexer::qstring");

                        // get rid of beginning and trailing quotes
                        std::string strWithQuotes = yytext;
                        std::string str = strWithQuotes.substr(1, strWithQuotes.size() - 2);
                        
                        // convert any escape characters
                        TSTRING strW;
                        cParserUtil::InterpretEscapedString( str, strW );
                        
                        d.TraceDetail(_T("read as        --> <%s>\n"), strW.c_str());

                        // convert TSTRING to cParseString
                        cParseString *mpstring = new cParseString;
                        ASSERT(mpstring);
                        *mpstring = strW;


                        d.TraceDetail("interpreted as --> <%s>\n", mpstring->c_str());

                        // attach to lval
                        yylval.mpString = mpstring;
                        return TWP_GLOBAL_STRING;
                    }
    break;
    case 8:
// #line 182 "tokens.l"
    { TRACE_RETURN(TWP_SEMICOLON);      }
    break;
    case 9:
// #line 183 "tokens.l"
    { TRACE_RETURN(TWP_EQUALS);         }
    break;
    case 10:
// #line 185 "tokens.l"
    { cParserHelper::IncrementLineNumber(); }
    break;
    case 11:
// #line 186 "tokens.l"
    {
                            std::string strError;
                            strError = FormatSyntaxError( yytext[0], "The global section only accepts statements of the form:\n variable = value;\n" );

                            yyerror( strError.c_str()); 
                        } /* catches anything that cannot be deemed a variable definition and exits. */
    break;
    case 12:
// #line 196 "tokens.l"
    { 
                        lextrace(_T("eating spaces...")); /* eat spaces */ 
                    }
    break;
    case 13:
// #line 200 "tokens.l"
    {   
                        cParserHelper::IncrementLineNumber();
                        lextrace(_T("eating line continuation...")); /* eat line continuations */ 
                    }
    break;
    case 14:
// #line 205 "tokens.l"
    { 
                        lextrace(_T("eating comment..."));
                    }
    break;
    case 15:
// #line 209 "tokens.l"
    { TRACE_RETURN(TWP_LBRACE);         }
    break;
    case 16:
// #line 210 "tokens.l"
    { TRACE_RETURN(TWP_RBRACE);         }
    break;
    case 17:
// #line 213 "tokens.l"
    { TRACE_RETURN(TWP_BANG);           }
    break;
    case 18:
// #line 215 "tokens.l"
    { TRACE_RETURN(TWP_RARROW);         }
    break;
    case 19:
// #line 216 "tokens.l"
    { TRACE_RETURN(TWP_EQUALS);         }
    break;
    case 20:
// #line 218 "tokens.l"
    { TRACE_RETURN(TWP_SEMICOLON);      }
    break;
    case 21:
// #line 219 "tokens.l"
    { TRACE_RETURN(TWP_LPAREN);         }
    break;
    case 22:
// #line 220 "tokens.l"
    { TRACE_RETURN(TWP_RPAREN);         }
    break;
    case 23:
// #line 221 "tokens.l"
    { TRACE_RETURN(TWP_COMMA);          }
    break;
    case 24:
// #line 222 "tokens.l"
    { TRACE_RETURN(TWP_PIPE); }
    break;
    case 25:
// #line 226 "tokens.l"
    { TRACE_RETURN(TWP_DOLLAR);         }
    break;
    case 26:
// #line 227 "tokens.l"
    { TRACE_RETURN(TWP_OROR); }
    break;
    case 27:
// #line 230 "tokens.l"
    { TRACE_RETURN(TWP_SECTION); }
    break;
    case 28:
// #line 231 "tokens.l"
    { TRACE_RETURN(TWP_IFHOST); }
    break;
    case 29:
// #line 232 "tokens.l"
    { TRACE_RETURN(TWP_ELSE); }
    break;
    case 30:
// #line 233 "tokens.l"
    { TRACE_RETURN(TWP_ENDIF); }
    break;
    case 31:
// #line 234 "tokens.l"
    { TRACE_RETURN(TWP_ERROR); }
    break;
    case 32:
// #line 235 "tokens.l"
    { TRACE_RETURN(TWP_ECHO); }
    break;
    case 33:
// #line 236 "tokens.l"
    { lextrace( _T( "@@end" ) ); return 0; } /* logical end of file */
    break;
    case 34:
// #line 239 "tokens.l"
    { 
                        // we must make copy of string, otherwise another lexeme will clobber it
                        cDebug d("\t\t\t\tlexer::string");
                        
                        // convert LPCSTR to TSTRING
                        cParseString *mpstring = new cParseString;
                        ASSERT(mpstring);
                        *mpstring = cStringUtil::StrToTstr( yytext );

                        d.TraceDetail("--> <%s>\n", mpstring->c_str());

                        // attach to lval
                        yylval.mpString = mpstring;
                        
                        return TWP_STRING;
                    }
    break;
    case 35:
// #line 256 "tokens.l"
    {
                        // we must make copy of string, otherwise another lexeme will clobber it
                        cDebug d("\t\t\t\tlexer::qstring");
                        
                        // get rid of beginning and trailing quotes
                        std::string strWithQuotes = yytext;
                        std::string str = strWithQuotes.substr(1, strWithQuotes.size() - 2);
                        
                        // convert any escape characters
                        TSTRING strW;
                        cParserUtil::InterpretEscapedString( str, strW );
                        
                        d.TraceDetail(_T("read as        --> <%s>\n"), strW.c_str());

                        if( cPreprocessor::GetState() == cPreprocessor::STATE_ACCEPT )
                        {
                            cParserHelper::GetGenreInfo()->DoVarSubstitution( strW );
                        }

                        // convert TSTRING to cParseString
                        cParseString *mpstring = new cParseString;
                        ASSERT(mpstring);
                        *mpstring = strW;


#ifdef DEBUG
                        TSTRING strDisplay = *mpstring;                        
                        cDisplayEncoder e;
                        e.Encode( strDisplay );
                        d.TraceDetail("interpreted as --> <%s>\n", strDisplay.c_str());
#endif // DEBUG

                        // attach to lval
                        yylval.mpString = mpstring;
                        return TWP_STRING;
                    }
    break;
    case 36:
// #line 309 "tokens.l"
    { cParserHelper::IncrementLineNumber(); }
    break;
    case 37:
// #line 310 "tokens.l"
    {
                        std::string strError;
                        strError = FormatSyntaxError( yytext[0] );
                        
                        yyerror( strError.c_str() );
                    } /* catches anything else that's not in here and quits */
    break;

// #line 487 "..\\..\\mkslexyacc\\etc\\yylex.cpp"

    }
    YY_SCANNER();
    i = yyleng;
    goto yy_again;          /* action fell though */

  yy_reject:
    YY_SCANNER();
    i = yyoleng;            /* restore original yytext */
    if (++yyfmin < yyfmax)
        goto yy_found;      /* another final state, same length */
    else
        goto yy_search;     /* try shorter yytext */

  yy_more:
    YY_SCANNER();
    i = yyleng;
    if (i > 0)
        yy_lastc = yytext[i-1];
    goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
yy_scan::yy_reset()
{
    YY_INIT();
    yylineno = 1;
}
/* get input char with pushback */
int
yy_scan::input()
{
    int c;
#ifndef YY_PRESERVE
    if (yy_end > yyleng) {
        yy_end--;
        memmove(yytext+yyleng, yytext+yyleng+1,
            (size_t) (yy_end-yyleng));
        c = save;
        YY_USER();
#else
    if (push < save+size) {
        c = *push++;
#endif
    } else
        c = yygetc();
    yy_lastc = c;
    if (c == YYNEWLINE)
        yylineno++;
    return c;
}

/* pushback char */
int
yy_scan::unput(int c)
{
#ifndef YY_PRESERVE
    if (yy_end >= size) {
        YY_FATAL("Push-back buffer overflow");
    } else {
        if (yy_end > yyleng) {
            yytext[yyleng] = save;
            memmove(yytext+yyleng+1, yytext+yyleng,
                (size_t) (yy_end-yyleng));
            yytext[yyleng] = 0;
        }
        yy_end++;
        save = c;
#else
    if (push <= save) {
        YY_FATAL("Push-back buffer overflow");
    } else {
        *--push = c;
#endif
        if (c == YYNEWLINE)
            yylineno--;
    }   /* endif */
    return c;
}

// #line 321 "tokens.l"



